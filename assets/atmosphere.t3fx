#version 330 core
out vec4 FragColor;
in vec2 vTex;
in vec4 aPosition;
uniform sampler2D screenTexture;
uniform sampler2D depthTexture;
uniform float camNear;
uniform float camFar;
uniform mat4 camView;
uniform mat4 camProjection;
uniform mat4 camInverseView;
uniform mat4 camInverseProjection;
uniform vec3 camPos;
uniform float time;

const vec3 sunDir = normalize(vec3(0.3, 0.7, 0.2));

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0;
    return (2.0 * camNear * camFar) / (camFar + camNear - z * (camFar - camNear));
}

void BuildRay(mat4 invV, mat4 invP, vec2 uv, out vec3 rayDir)
{
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clip = vec4(ndc, 1.0, 1.0);
    vec4 view = invP * clip;
    view /= view.w;
    vec4 world = invV * view;
    rayDir = normalize(world.xyz - camPos);
}

float hash(vec2 p)
{
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p)
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p)
{
    return noise(p) * 0.5 + noise(p * 2.1) * 0.25;
}

vec3 GetSkyColor(vec3 dir)
{
    float sunDot = dot(dir, sunDir);
    float y = max(0.0, dir.y);
    
    vec3 skyTop = vec3(0.3, 0.5, 0.9);
    vec3 skyHorizon = vec3(0.7, 0.8, 0.95);
    vec3 skyColor = mix(skyHorizon, skyTop, pow(y, 0.4));
    
    float sun = smoothstep(0.9995, 0.9998, sunDot);
    skyColor += vec3(1.0, 0.95, 0.8) * sun * 15.0;
    
    float glow = pow(max(0.0, sunDot), 8.0);
    skyColor += vec3(1.0, 0.9, 0.7) * glow * 0.3;
    
    return skyColor;
}

vec3 GetClouds(vec3 dir, vec3 sky)
{
    if(dir.y < 0.05) return sky;
    
    vec2 uv = dir.xz / max(dir.y, 0.1);
    vec2 cloudUV = uv * 0.5;
    
    float cloudDensity = 0.0;
    
    vec2 p1 = cloudUV + time * 0.02;
    float n1 = fbm(p1 * 1.5);
    cloudDensity += smoothstep(0.4, 0.8, n1) * 0.9;
    
    vec2 p2 = cloudUV * 1.3 + time * 0.015 + vec2(100.0);
    float n2 = fbm(p2 * 2.0);
    cloudDensity += smoothstep(0.5, 0.85, n2) * 0.7;
    
    vec2 p3 = cloudUV * 2.5 + time * 0.01 + vec2(200.0);
    float n3 = noise(p3 * 3.0);
    cloudDensity += smoothstep(0.6, 0.9, n3) * 0.5;
    
    cloudDensity *= smoothstep(0.05, 0.2, dir.y);
    cloudDensity = clamp(cloudDensity, 0.0, 1.0);
    
    float sunLight = max(0.0, sunDir.y) * 0.5 + 0.5;
    vec3 cloudBright = vec3(1.0, 0.98, 0.95) * sunLight;
    vec3 cloudDark = vec3(0.6, 0.65, 0.7) * sunLight;
    vec3 cloudColor = mix(cloudDark, cloudBright, n1 * 0.5 + 0.5);
    
    return mix(sky, cloudColor, cloudDensity * 0.85);
}

void main()
{
    float depth = texture(depthTexture, vTex).r;
    float linearDepth = LinearizeDepth(depth);

    vec3 rayDir;
    BuildRay(camInverseView, camInverseProjection, vTex, rayDir);

    vec3 finalColor;
    
    if(linearDepth > camFar * 0.95)
    {
        vec3 skyColor = GetSkyColor(rayDir);
        finalColor = GetClouds(rayDir, skyColor);
    }
    else
    {
        vec3 sceneColor = texture(screenTexture, vTex).rgb;
        vec3 skyColor = GetSkyColor(rayDir);
        
        float distance = linearDepth;
        float fogAmount = 1.0 - exp(-distance * distance * 0.00012 * 0.00012);
        fogAmount = clamp(fogAmount, 0.0, 0.8);
        
        float heightFactor = exp(-max(0.0, camPos.y) * 0.001);
        fogAmount *= (0.25 + 0.75 * heightFactor);
        
        finalColor = mix(sceneColor, skyColor, fogAmount);
    }

    FragColor = vec4(finalColor, 1.0);
}
