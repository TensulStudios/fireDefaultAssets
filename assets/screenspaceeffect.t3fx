#version 330 core
		
		uniform sampler2D screenTexture;
		uniform sampler2D gFinalImage;
		uniform sampler2D gPosition;
		uniform sampler2D gNormal;
		uniform sampler2D gExtraComponents;
		uniform sampler2D noiseTexture;
		
		uniform mat4 camView;
		uniform mat4 camProjection;
		uniform mat4 camInverseView;
		uniform mat4 camInverseProjection;
		uniform float fogDensity;
		
		noperspective in vec2 vTex;
		
		out vec4 FragColor;
		
		const float rayStep = 0.2;
		const int maxSteps = 35;
		const int numBinarySearchSteps = 7;
		const float depthThickness = 0.7;
		
		const int kernelSize = 16;
		const float aoRadius = 0.5;
		const float aoBias = 0.025;
		const float aoIntensity = 1.5;
		const vec2 noiseScale = vec2(1920.0/4.0, 1080.0/4.0);
		
		const vec3 kernel[16] = vec3[](
			vec3(0.04977, -0.04471, 0.04996),
			vec3(-0.01678, 0.01807, 0.00833),
			vec3(-0.04875, -0.04805, 0.04977),
			vec3(-0.00915, -0.00568, 0.00354),
			vec3(-0.05691, 0.05911, 0.04705),
			vec3(-0.00387, -0.01430, 0.00599),
			vec3(0.05199, 0.01294, 0.04858),
			vec3(-0.00881, 0.00354, 0.00106),
			vec3(-0.08679, 0.04300, 0.06048),
			vec3(0.00986, -0.00190, 0.00053),
			vec3(-0.00747, 0.04951, 0.01230),
			vec3(0.01834, -0.00610, 0.00275),
			vec3(0.01436, 0.03129, 0.00758),
			vec3(-0.10535, -0.02529, 0.09060),
			vec3(-0.00681, 0.00763, 0.00106),
			vec3(0.07990, 0.01799, 0.06063)
		);
		
		vec3 projectToScreen(vec3 viewPos, out vec2 screenUV)
		{
			vec4 proj = camProjection * vec4(viewPos, 1.0);
			screenUV = (proj.xy / proj.w) * 0.5 + 0.5;
			return vec3(screenUV, proj.z);
		}
		
		vec3 BinarySearch(vec3 dir, inout vec3 hitCoord, inout float dDepth)
		{
			vec2 screenUV;
			float depth;
			
			for(int i = 0; i < numBinarySearchSteps; i++)
			{
				projectToScreen(hitCoord, screenUV);
				depth = textureLod(gPosition, screenUV, 2.0).z;
				dDepth = hitCoord.z - depth;
				
				dir *= 0.5;
				hitCoord += (dDepth > 0.0) ? dir : -dir;
			}
			
			projectToScreen(hitCoord, screenUV);
			return vec3(screenUV, depth);
		}
		
		vec4 RayCast(vec3 dir, inout vec3 hitCoord, out float dDepth)
		{
			dir *= rayStep;
			vec2 screenUV;
			float depth;
			
			for(int i = 0; i < maxSteps; i++)
			{
				hitCoord += dir;
				projectToScreen(hitCoord, screenUV);
				
				if(screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0)
					return vec4(screenUV, 0.0, 0.0);
				
				depth = textureLod(gPosition, screenUV, 2.0).z;
				
				if (depth < 1000.0)
				{
					dDepth = hitCoord.z - depth;
					
					if (dDepth > 0.0 && dDepth < depthThickness)
					{
						vec3 result = BinarySearch(dir, hitCoord, dDepth);
						return vec4(result, 1.0);
					}
				}
			}
			
			return vec4(screenUV, depth, 0.0);
		}
		
		float getScreenEdgeFade(vec2 uv)
		{
			vec2 fade = max(vec2(0.0), 12.0 * abs(uv - 0.5) - 5.0);
			return clamp(1.0 - dot(fade, fade), 0.0, 1.0);
		}
		
		float calculateAO(vec3 viewPos, vec3 normal, float fadeAmount)
		{
			float aoStrength = 1.0 - fadeAmount;
			if(aoStrength < 0.1) return 1.0;
			
			vec3 randomVec = texture(noiseTexture, vTex * noiseScale).xyz * 2.0 - 1.0;
			vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
			vec3 bitangent = cross(normal, tangent);
			mat3 TBN = mat3(tangent, bitangent, normal);
			float occlusion = 0.0;
			float validSamples = 0.0;
			
			for(int i = 0; i < kernelSize; i++)
			{
				vec3 samplePos = TBN * kernel[i];
				samplePos = viewPos + samplePos * aoRadius;
				
				vec4 offset = camProjection * vec4(samplePos, 1.0);
				offset.xyz /= offset.w;
				offset.xy = offset.xy * 0.5 + 0.5;
				
				if(offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0)
					continue;
				
				float sampleDepth = texture(gPosition, offset.xy).z;
			
				if(sampleDepth > 1000.0)
					continue;
				
				float rangeCheck = smoothstep(0.0, 1.0, aoRadius / abs(viewPos.z - sampleDepth));
				occlusion += (sampleDepth >= samplePos.z + aoBias ? 1.0 : 0.0) * rangeCheck;
				validSamples += 1.0;
			}
			
			occlusion = validSamples > 0.0 ? occlusion / validSamples : 0.0;
			occlusion = 1.0 - (occlusion * aoIntensity);
			
			return mix(1.0, occlusion, aoStrength);
		}
		
		void main() 
		{
			vec2 MetallicRoughness = vec2(0.3, 0.2);
			vec3 viewPos = texture(gPosition, vTex).xyz;
			vec3 albedo = texture(gFinalImage, vTex).rgb;
			
			float viewPosLen = dot(viewPos, viewPos);
			if(viewPosLen > 1000000.0)
			{
				FragColor = vec4(albedo, 1.0);
				return;
			}
			
			float viewDist = sqrt(viewPosLen);
			float fogFactor = 1.0 - exp(-fogDensity * fogDensity * viewDist * viewDist);
			
			float metallic = MetallicRoughness.r;
			float roughness = MetallicRoughness.g;
			float spec = texture(screenTexture, vTex).a;
			
			vec3 worldNormal = texture(gNormal, vTex).xyz * 2.0 - 1.0;
			vec3 viewNormal = normalize(mat3(camView) * worldNormal);
		
			float aoFactor = calculateAO(viewPos, viewNormal, fogFactor);
			
			vec3 finalColor = albedo * aoFactor;
			
			if(metallic < 0.01 && spec < 0.01)
			{
				FragColor = vec4(finalColor, 1.0);
				return;
			}
			
			vec3 viewDir = viewPos * inversesqrt(viewPosLen);
			vec3 reflected = reflect(viewDir, viewNormal);
			
			if(reflected.z > 0.2)
			{
				FragColor = vec4(finalColor, 1.0);
				return;
			}
			
			vec3 hitPos = viewPos + reflected * 0.5;
			float dDepth;
			vec4 coords = RayCast(reflected, hitPos, dDepth);
			
			float screenEdgeFade = getScreenEdgeFade(coords.xy);
			
			float rayDistance = length(hitPos - viewPos);
			float distanceFade = 1.0 - smoothstep(10.0, 30.0, rayDistance);
			
			float angleFade = pow(clamp(dot(-viewDir, viewNormal), 0.0, 1.0), 0.5);
			
			float combinedFade = screenEdgeFade * distanceFade * angleFade * 0.3;
			
			float reflectionIntensity = (1.0 - roughness);

			float fresnel = pow(1.0 - clamp(dot(-viewDir, viewNormal), 0.0, 1.0), 5.0);
			reflectionIntensity = mix(reflectionIntensity * metallic, reflectionIntensity, fresnel);
			
			vec3 reflectionColor = vec3(0.0);
			if(coords.w > 0.5)
			{
				reflectionColor = textureLod(gFinalImage, coords.xy, roughness * 4.0).rgb;
			}
			
			float finalReflectionStrength = reflectionIntensity * coords.w * combinedFade;
			
			FragColor = vec4(mix(finalColor, reflectionColor, finalReflectionStrength), 1.0);
		}
