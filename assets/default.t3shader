#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTex;

out vec3 FragPos;
out vec3 ViewPos;
out vec3 Normal;
out vec2 texCoord;
out vec4 fragPosLight;
out mat3 TBN;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform mat4 lightSpaceMatrix;
uniform mat3 normalMatrix;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    ViewPos = (view * worldPos).xyz;
    Normal = normalMatrix * aNormal;
    texCoord = aTex;
    fragPosLight = lightSpaceMatrix * worldPos;
    
    vec3 T = normalize(vec3(model * vec4(1.0, 0.0, 0.0, 0.0)));
    vec3 N = normalize(Normal);
    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}// sep_frag_vert \\#version 330 core

layout(location = 0) out vec4 gFinalImage;
layout(location = 1) out vec4 gPosition;
layout(location = 2) out vec4 gNormal;
layout(location = 3) out vec4 gExtraComponents;

in vec3 FragPos;
in vec3 ViewPos;
in vec3 Normal;
in vec2 texCoord;
in vec4 fragPosLight;
in mat3 TBN;

uniform sampler2D material_albedoMap;
uniform sampler2D material_normalMap;
uniform sampler2D material_metallicMap;
uniform sampler2D material_roughnessMap;
uniform sampler2D material_aoMap;
uniform sampler2D material_emissiveMap;

uniform vec3 material_baseColor;
uniform float material_metallic;
uniform float material_roughness;
uniform vec3 material_emissiveColor;
uniform float material_emissiveStrength;

uniform sampler2D tex;
uniform sampler2D shadowMap;
uniform sampler2D debugTex;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 fogColor;
uniform vec3 lightColor;
uniform float fogDensity;
uniform float ambientLight;
uniform float time;
uniform bool missingTex;
uniform bool legacyTex;
uniform float lightRadius;

uniform bool hasNormalMap;
uniform bool hasMetallicMap;
uniform bool hasRoughnessMap;
uniform bool hasAOMap;
uniform bool hasEmissiveMap;

const float PI = 3.14159265359;

vec3 getNormalFromMap()
{
    if (!hasNormalMap)
        return normalize(Normal);
    
    vec3 tangentNormal = texture(material_normalMap, texCoord).xyz * 2.0 - 1.0;
    return normalize(TBN * tangentNormal);
}

float ShadowCalculation(vec4 fragPosLightSpace, vec3 normal, vec3 lightDirection, float distanceToCamera)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;

    if (projCoords.z > 1.0 || any(lessThan(projCoords.xy, vec2(0.0))) || any(greaterThan(projCoords.xy, vec2(1.0))))
        return 0.0;

    float bias = max(0.003 * (1.0 - dot(normal, lightDirection)), 0.001);
    float currentDepth = projCoords.z - bias;

    if (distanceToCamera < 12.0)
    {
        vec2 texelSize = 1.0 / vec2(textureSize(shadowMap, 0));
        float shadow = 0.0;
        
        shadow += (currentDepth > texture(shadowMap, projCoords.xy + vec2(-1, -1) * texelSize).r) ? 0.25 : 0.0;
        shadow += (currentDepth > texture(shadowMap, projCoords.xy + vec2( 1, -1) * texelSize).r) ? 0.25 : 0.0;
        shadow += (currentDepth > texture(shadowMap, projCoords.xy + vec2(-1,  1) * texelSize).r) ? 0.25 : 0.0;
        shadow += (currentDepth > texture(shadowMap, projCoords.xy + vec2( 1,  1) * texelSize).r) ? 0.25 : 0.0;
        
        return shadow;
    }
    else if (distanceToCamera < 25.0)
    {
        float closestDepth = texture(shadowMap, projCoords.xy).r;
        return (currentDepth > closestDepth) ? 1.0 : 0.0;
    }
    
    return 0.0;
}

float ShadowCalculationFast(vec4 fragPosLightSpace, vec3 normal, vec3 lightDirection)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;

    if (projCoords.z > 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;

    float bias = max(0.003 * (1.0 - dot(normal, lightDirection)), 0.001);
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    float currentDepth = projCoords.z - bias;
    
    return (currentDepth > closestDepth) ? 1.0 : 0.0;
}

vec3 calculatePBRLighting(vec3 albedo, vec3 normal, float metallic, float roughness, float ao, vec3 lightDir, vec3 viewDir, float shadow)
{
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);
    
    vec3 H = normalize(viewDir + lightDir);
    float NdotL = max(dot(normal, lightDir), 0.0);
    float NdotV = max(dot(normal, viewDir), 0.0);
    float NdotH = max(dot(normal, H), 0.0);
    
    float specPower = mix(8.0, 256.0, 1.0 - roughness);
    float spec = pow(NdotH, specPower);
    
    float cosTheta = max(dot(H, viewDir), 0.0);
    vec3 F = F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    
    vec3 diffuse = kD * albedo / PI;
    
    vec3 specular = kS * spec;
    
    vec3 lighting = (diffuse + specular) * lightColor * NdotL * (1.0 - shadow);
    
    vec3 ambient = albedo * ambientLight * ao;
    
    return ambient + lighting;
}

void main()
{
    vec4 albedoSample = legacyTex ? texture(debugTex, texCoord) : texture(material_albedoMap, texCoord);
    
    if (legacyTex || missingTex)
    {
        gFinalImage = texture(debugTex, texCoord);
        gPosition = vec4(ViewPos, 1.0);
        gNormal = vec4(normalize(Normal) * 0.5 + 0.5, 1.0);
        gExtraComponents = vec4(0.0, 0.5, 0.0, 1.0);
        return;
    }
    
    if (albedoSample.a < 0.75) discard;
    
    vec3 albedo = pow(albedoSample.rgb, vec3(2.2)) * material_baseColor;
    float metallic = hasMetallicMap ? texture(material_metallicMap, texCoord).r * material_metallic : material_metallic;
    float roughness = hasRoughnessMap ? texture(material_roughnessMap, texCoord).r * material_roughness : material_roughness;
    float ao = hasAOMap ? texture(material_aoMap, texCoord).r : 1.0;
    vec3 emissive = hasEmissiveMap ? texture(material_emissiveMap, texCoord).rgb * material_emissiveColor * material_emissiveStrength : vec3(0.0);
    
    vec3 normal = getNormalFromMap();
    
    float distanceToCamera = length(viewPos - FragPos);
    
    vec3 finalColor;
    
    if (distanceToCamera > 40.0)
    {
        float fogFactor = 1.0 - exp(-fogDensity * fogDensity * distanceToCamera * distanceToCamera);
        finalColor = mix(albedo * ambientLight * ao, fogColor, clamp(fogFactor, 0.0, 1.0));
    }
    else
    {
        vec3 lightVector = normalize(lightPos - FragPos);
        vec3 viewVector = normalize(viewPos - FragPos);
        
        float shadow = (distanceToCamera < 25.0) ? 
            ShadowCalculationFast(fragPosLight, normal, lightVector) : 0.0;
        
        vec3 litColor = calculatePBRLighting(albedo, normal, metallic, roughness, ao, lightVector, viewVector, shadow);
        
        litColor += emissive;
        
        float viewDist = length(ViewPos);
        float fogFactor = 1.0 - exp(-fogDensity * fogDensity * viewDist * viewDist);
        
        finalColor = mix(litColor, fogColor, clamp(fogFactor, 0.0, 1.0));
    }
    
    finalColor = pow(finalColor, vec3(1.0 / 2.2));
    
    gFinalImage = vec4(finalColor, albedoSample.a);
    gPosition = vec4(ViewPos, 1.0);
    gNormal = vec4(normal * 0.5 + 0.5, 1.0);
    gExtraComponents = vec4(metallic, roughness, ao, 1.0);
}
